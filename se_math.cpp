#include "se_math.h"

namespace SE_CORE
{
	float mat4det(mat4 Xm)
	{
		float det;

		det = \
			Xm[0][3] * Xm[1][2] * Xm[2][1] * Xm[3][0] \
			- Xm[0][2] * Xm[1][3] * Xm[2][1] * Xm[3][0] \
			- Xm[0][3] * Xm[1][1] * Xm[2][2] * Xm[3][0] \
			+ Xm[0][1] * Xm[1][3] * Xm[2][2] * Xm[3][0] \
			+ Xm[0][2] * Xm[1][1] * Xm[2][3] * Xm[3][0] \
			- Xm[0][1] * Xm[1][2] * Xm[2][3] * Xm[3][0] \
			- Xm[0][3] * Xm[1][2] * Xm[2][0] * Xm[3][1] \
			+ Xm[0][2] * Xm[1][3] * Xm[2][0] * Xm[3][1] \
			+ Xm[0][3] * Xm[1][0] * Xm[2][2] * Xm[3][1] \
			- Xm[0][0] * Xm[1][3] * Xm[2][2] * Xm[3][1] \
			- Xm[0][2] * Xm[1][0] * Xm[2][3] * Xm[3][1] \
			+ Xm[0][0] * Xm[1][2] * Xm[2][3] * Xm[3][1] \
			+ Xm[0][3] * Xm[1][1] * Xm[2][0] * Xm[3][2] \
			- Xm[0][1] * Xm[1][3] * Xm[2][0] * Xm[3][2] \
			- Xm[0][3] * Xm[1][0] * Xm[2][1] * Xm[3][2] \
			+ Xm[0][0] * Xm[1][3] * Xm[2][1] * Xm[3][2] \
			+ Xm[0][1] * Xm[1][0] * Xm[2][3] * Xm[3][2] \
			- Xm[0][0] * Xm[1][1] * Xm[2][3] * Xm[3][2] \
			- Xm[0][2] * Xm[1][1] * Xm[2][0] * Xm[3][3] \
			+ Xm[0][1] * Xm[1][2] * Xm[2][0] * Xm[3][3] \
			+ Xm[0][2] * Xm[1][0] * Xm[2][1] * Xm[3][3] \
			- Xm[0][0] * Xm[1][2] * Xm[2][1] * Xm[3][3] \
			- Xm[0][1] * Xm[1][0] * Xm[2][2] * Xm[3][3] \
			+ Xm[0][0] * Xm[1][1] * Xm[2][2] * Xm[3][3] \
			;

		return det;
	}

	mat4 inverseMat4(mat4 Xm)
	{
		mat4 outm;
		float det_val = mat4det(Xm);

		outm[0][0] = (Xm[1][2] * Xm[2][3] * Xm[3][1] - Xm[1][3] * Xm[2][2] * Xm[3][1] + Xm[1][3] * Xm[2][1] * Xm[3][2] - Xm[1][1] * Xm[2][3] * Xm[3][2] - Xm[1][2] * Xm[2][1] * Xm[3][3] + Xm[1][1] * Xm[2][2] * Xm[3][3]) / det_val;
		outm[1][0] = (Xm[1][3] * Xm[2][2] * Xm[3][0] - Xm[1][2] * Xm[2][3] * Xm[3][0] - Xm[1][3] * Xm[2][0] * Xm[3][2] + Xm[1][0] * Xm[2][3] * Xm[3][2] + Xm[1][2] * Xm[2][0] * Xm[3][3] - Xm[1][0] * Xm[2][2] * Xm[3][3]) / det_val;
		outm[2][0] = (Xm[1][1] * Xm[2][3] * Xm[3][0] - Xm[1][3] * Xm[2][1] * Xm[3][0] + Xm[1][3] * Xm[2][0] * Xm[3][1] - Xm[1][0] * Xm[2][3] * Xm[3][1] - Xm[1][1] * Xm[2][0] * Xm[3][3] + Xm[1][0] * Xm[2][1] * Xm[3][3]) / det_val;
		outm[3][0] = (Xm[1][2] * Xm[2][1] * Xm[3][0] - Xm[1][1] * Xm[2][2] * Xm[3][0] - Xm[1][2] * Xm[2][0] * Xm[3][1] + Xm[1][0] * Xm[2][2] * Xm[3][1] + Xm[1][1] * Xm[2][0] * Xm[3][2] - Xm[1][0] * Xm[2][1] * Xm[3][2]) / det_val;
		outm[0][1] = (Xm[0][3] * Xm[2][2] * Xm[3][1] - Xm[0][2] * Xm[2][3] * Xm[3][1] - Xm[0][3] * Xm[2][1] * Xm[3][2] + Xm[0][1] * Xm[2][3] * Xm[3][2] + Xm[0][2] * Xm[2][1] * Xm[3][3] - Xm[0][1] * Xm[2][2] * Xm[3][3]) / det_val;
		outm[1][1] = (Xm[0][2] * Xm[2][3] * Xm[3][0] - Xm[0][3] * Xm[2][2] * Xm[3][0] + Xm[0][3] * Xm[2][0] * Xm[3][2] - Xm[0][0] * Xm[2][3] * Xm[3][2] - Xm[0][2] * Xm[2][0] * Xm[3][3] + Xm[0][0] * Xm[2][2] * Xm[3][3]) / det_val;
		outm[2][1] = (Xm[0][3] * Xm[2][1] * Xm[3][0] - Xm[0][1] * Xm[2][3] * Xm[3][0] - Xm[0][3] * Xm[2][0] * Xm[3][1] + Xm[0][0] * Xm[2][3] * Xm[3][1] + Xm[0][1] * Xm[2][0] * Xm[3][3] - Xm[0][0] * Xm[2][1] * Xm[3][3]) / det_val;
		outm[3][1] = (Xm[0][1] * Xm[2][2] * Xm[3][0] - Xm[0][2] * Xm[2][1] * Xm[3][0] + Xm[0][2] * Xm[2][0] * Xm[3][1] - Xm[0][0] * Xm[2][2] * Xm[3][1] - Xm[0][1] * Xm[2][0] * Xm[3][2] + Xm[0][0] * Xm[2][1] * Xm[3][2]) / det_val;
		outm[0][2] = (Xm[0][2] * Xm[1][3] * Xm[3][1] - Xm[0][3] * Xm[1][2] * Xm[3][1] + Xm[0][3] * Xm[1][1] * Xm[3][2] - Xm[0][1] * Xm[1][3] * Xm[3][2] - Xm[0][2] * Xm[1][1] * Xm[3][3] + Xm[0][1] * Xm[1][2] * Xm[3][3]) / det_val;
		outm[1][2] = (Xm[0][3] * Xm[1][2] * Xm[3][0] - Xm[0][2] * Xm[1][3] * Xm[3][0] - Xm[0][3] * Xm[1][0] * Xm[3][2] + Xm[0][0] * Xm[1][3] * Xm[3][2] + Xm[0][2] * Xm[1][0] * Xm[3][3] - Xm[0][0] * Xm[1][2] * Xm[3][3]) / det_val;
		outm[2][2] = (Xm[0][1] * Xm[1][3] * Xm[3][0] - Xm[0][3] * Xm[1][1] * Xm[3][0] + Xm[0][3] * Xm[1][0] * Xm[3][1] - Xm[0][0] * Xm[1][3] * Xm[3][1] - Xm[0][1] * Xm[1][0] * Xm[3][3] + Xm[0][0] * Xm[1][1] * Xm[3][3]) / det_val;
		outm[3][2] = (Xm[0][2] * Xm[1][1] * Xm[3][0] - Xm[0][1] * Xm[1][2] * Xm[3][0] - Xm[0][2] * Xm[1][0] * Xm[3][1] + Xm[0][0] * Xm[1][2] * Xm[3][1] + Xm[0][1] * Xm[1][0] * Xm[3][2] - Xm[0][0] * Xm[1][1] * Xm[3][2]) / det_val;
		outm[0][3] = (Xm[0][3] * Xm[1][2] * Xm[2][1] - Xm[0][2] * Xm[1][3] * Xm[2][1] - Xm[0][3] * Xm[1][1] * Xm[2][2] + Xm[0][1] * Xm[1][3] * Xm[2][2] + Xm[0][2] * Xm[1][1] * Xm[2][3] - Xm[0][1] * Xm[1][2] * Xm[2][3]) / det_val;
		outm[1][3] = (Xm[0][2] * Xm[1][3] * Xm[2][0] - Xm[0][3] * Xm[1][2] * Xm[2][0] + Xm[0][3] * Xm[1][0] * Xm[2][2] - Xm[0][0] * Xm[1][3] * Xm[2][2] - Xm[0][2] * Xm[1][0] * Xm[2][3] + Xm[0][0] * Xm[1][2] * Xm[2][3]) / det_val;
		outm[2][3] = (Xm[0][3] * Xm[1][1] * Xm[2][0] - Xm[0][1] * Xm[1][3] * Xm[2][0] - Xm[0][3] * Xm[1][0] * Xm[2][1] + Xm[0][0] * Xm[1][3] * Xm[2][1] + Xm[0][1] * Xm[1][0] * Xm[2][3] - Xm[0][0] * Xm[1][1] * Xm[2][3]) / det_val;
		outm[3][3] = (Xm[0][1] * Xm[1][2] * Xm[2][0] - Xm[0][2] * Xm[1][1] * Xm[2][0] + Xm[0][2] * Xm[1][0] * Xm[2][1] - Xm[0][0] * Xm[1][2] * Xm[2][1] - Xm[0][1] * Xm[1][0] * Xm[2][2] + Xm[0][0] * Xm[1][1] * Xm[2][2]) / det_val;

		return outm;
	}

	bool rayTriangleIntersect(const vec3& org, const vec3& dir, const triangle_t& t)
	{
		vec3 cam = dir;
		vec3 e[3];
		vec3 n;

		e[0] = t.v[0] - org;
		e[1] = t.v[1] - org;
		e[2] = t.v[2] - org;

		uint32_t vecIdx0[3] = { 0,1,2 };
		uint32_t vecIdx1[3] = { 1,2,0 };

		for (uint32_t i = 0; i < 3; i++)
		{
			n = normalize(cross(e[vecIdx0[i]], e[vecIdx1[i]]));
			if (dot(n, cam) < 0)
				return false;
		}

		return true;
	}

	vec3 mat4MulVec3(const mat4& m, const vec3& v)
	{
		const float v1 = m[0][0] * v[0] + m[1][0] * v[1] + m[2][0] * v[2] + m[3][0];
		const float v2 = m[0][1] * v[0] + m[1][1] * v[1] + m[2][1] * v[2] + m[3][1];
		const float v3 = m[0][2] * v[0] + m[1][2] * v[1] + m[2][2] * v[2] + m[3][2];

		vec3 ov(v1, v2, v3);

		return ov;
	}
}